// Code generated by http://github.com/gojuno/minimock (v3.3.13). DO NOT EDIT.

package service

//go:generate minimock -i github.com/jumayevgadam/book_management/internals/author/service.AuthorDTO -o author_dto_mock_test.go -n AuthorDTOMock -p service

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	"github.com/jumayevgadam/book_management/internals/author/models"
)

// AuthorDTOMock implements AuthorDTO
type AuthorDTOMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreateAuthor          func(ctx context.Context, author *models.Author) (ap1 *models.Author, err error)
	inspectFuncCreateAuthor   func(ctx context.Context, author *models.Author)
	afterCreateAuthorCounter  uint64
	beforeCreateAuthorCounter uint64
	CreateAuthorMock          mAuthorDTOMockCreateAuthor

	funcDeleteAuthor          func(ctx context.Context, author_id int) (s1 string, err error)
	inspectFuncDeleteAuthor   func(ctx context.Context, author_id int)
	afterDeleteAuthorCounter  uint64
	beforeDeleteAuthorCounter uint64
	DeleteAuthorMock          mAuthorDTOMockDeleteAuthor

	funcGetAllAuthor          func(ctx context.Context, pagination models.PaginationForAuthor) (apa1 []*models.Author, err error)
	inspectFuncGetAllAuthor   func(ctx context.Context, pagination models.PaginationForAuthor)
	afterGetAllAuthorCounter  uint64
	beforeGetAllAuthorCounter uint64
	GetAllAuthorMock          mAuthorDTOMockGetAllAuthor

	funcGetAuthorByID          func(ctx context.Context, author_id int) (ap1 *models.Author, err error)
	inspectFuncGetAuthorByID   func(ctx context.Context, author_id int)
	afterGetAuthorByIDCounter  uint64
	beforeGetAuthorByIDCounter uint64
	GetAuthorByIDMock          mAuthorDTOMockGetAuthorByID

	funcUpdateAuthor          func(ctx context.Context, author_id int, update *models.UpdateInputAuthor) (s1 string, err error)
	inspectFuncUpdateAuthor   func(ctx context.Context, author_id int, update *models.UpdateInputAuthor)
	afterUpdateAuthorCounter  uint64
	beforeUpdateAuthorCounter uint64
	UpdateAuthorMock          mAuthorDTOMockUpdateAuthor
}

// NewAuthorDTOMock returns a mock for AuthorDTO
func NewAuthorDTOMock(t minimock.Tester) *AuthorDTOMock {
	m := &AuthorDTOMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateAuthorMock = mAuthorDTOMockCreateAuthor{mock: m}
	m.CreateAuthorMock.callArgs = []*AuthorDTOMockCreateAuthorParams{}

	m.DeleteAuthorMock = mAuthorDTOMockDeleteAuthor{mock: m}
	m.DeleteAuthorMock.callArgs = []*AuthorDTOMockDeleteAuthorParams{}

	m.GetAllAuthorMock = mAuthorDTOMockGetAllAuthor{mock: m}
	m.GetAllAuthorMock.callArgs = []*AuthorDTOMockGetAllAuthorParams{}

	m.GetAuthorByIDMock = mAuthorDTOMockGetAuthorByID{mock: m}
	m.GetAuthorByIDMock.callArgs = []*AuthorDTOMockGetAuthorByIDParams{}

	m.UpdateAuthorMock = mAuthorDTOMockUpdateAuthor{mock: m}
	m.UpdateAuthorMock.callArgs = []*AuthorDTOMockUpdateAuthorParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthorDTOMockCreateAuthor struct {
	optional           bool
	mock               *AuthorDTOMock
	defaultExpectation *AuthorDTOMockCreateAuthorExpectation
	expectations       []*AuthorDTOMockCreateAuthorExpectation

	callArgs []*AuthorDTOMockCreateAuthorParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthorDTOMockCreateAuthorExpectation specifies expectation struct of the AuthorDTO.CreateAuthor
type AuthorDTOMockCreateAuthorExpectation struct {
	mock      *AuthorDTOMock
	params    *AuthorDTOMockCreateAuthorParams
	paramPtrs *AuthorDTOMockCreateAuthorParamPtrs
	results   *AuthorDTOMockCreateAuthorResults
	Counter   uint64
}

// AuthorDTOMockCreateAuthorParams contains parameters of the AuthorDTO.CreateAuthor
type AuthorDTOMockCreateAuthorParams struct {
	ctx    context.Context
	author *models.Author
}

// AuthorDTOMockCreateAuthorParamPtrs contains pointers to parameters of the AuthorDTO.CreateAuthor
type AuthorDTOMockCreateAuthorParamPtrs struct {
	ctx    *context.Context
	author **models.Author
}

// AuthorDTOMockCreateAuthorResults contains results of the AuthorDTO.CreateAuthor
type AuthorDTOMockCreateAuthorResults struct {
	ap1 *models.Author
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateAuthor *mAuthorDTOMockCreateAuthor) Optional() *mAuthorDTOMockCreateAuthor {
	mmCreateAuthor.optional = true
	return mmCreateAuthor
}

// Expect sets up expected params for AuthorDTO.CreateAuthor
func (mmCreateAuthor *mAuthorDTOMockCreateAuthor) Expect(ctx context.Context, author *models.Author) *mAuthorDTOMockCreateAuthor {
	if mmCreateAuthor.mock.funcCreateAuthor != nil {
		mmCreateAuthor.mock.t.Fatalf("AuthorDTOMock.CreateAuthor mock is already set by Set")
	}

	if mmCreateAuthor.defaultExpectation == nil {
		mmCreateAuthor.defaultExpectation = &AuthorDTOMockCreateAuthorExpectation{}
	}

	if mmCreateAuthor.defaultExpectation.paramPtrs != nil {
		mmCreateAuthor.mock.t.Fatalf("AuthorDTOMock.CreateAuthor mock is already set by ExpectParams functions")
	}

	mmCreateAuthor.defaultExpectation.params = &AuthorDTOMockCreateAuthorParams{ctx, author}
	for _, e := range mmCreateAuthor.expectations {
		if minimock.Equal(e.params, mmCreateAuthor.defaultExpectation.params) {
			mmCreateAuthor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateAuthor.defaultExpectation.params)
		}
	}

	return mmCreateAuthor
}

// ExpectCtxParam1 sets up expected param ctx for AuthorDTO.CreateAuthor
func (mmCreateAuthor *mAuthorDTOMockCreateAuthor) ExpectCtxParam1(ctx context.Context) *mAuthorDTOMockCreateAuthor {
	if mmCreateAuthor.mock.funcCreateAuthor != nil {
		mmCreateAuthor.mock.t.Fatalf("AuthorDTOMock.CreateAuthor mock is already set by Set")
	}

	if mmCreateAuthor.defaultExpectation == nil {
		mmCreateAuthor.defaultExpectation = &AuthorDTOMockCreateAuthorExpectation{}
	}

	if mmCreateAuthor.defaultExpectation.params != nil {
		mmCreateAuthor.mock.t.Fatalf("AuthorDTOMock.CreateAuthor mock is already set by Expect")
	}

	if mmCreateAuthor.defaultExpectation.paramPtrs == nil {
		mmCreateAuthor.defaultExpectation.paramPtrs = &AuthorDTOMockCreateAuthorParamPtrs{}
	}
	mmCreateAuthor.defaultExpectation.paramPtrs.ctx = &ctx

	return mmCreateAuthor
}

// ExpectAuthorParam2 sets up expected param author for AuthorDTO.CreateAuthor
func (mmCreateAuthor *mAuthorDTOMockCreateAuthor) ExpectAuthorParam2(author *models.Author) *mAuthorDTOMockCreateAuthor {
	if mmCreateAuthor.mock.funcCreateAuthor != nil {
		mmCreateAuthor.mock.t.Fatalf("AuthorDTOMock.CreateAuthor mock is already set by Set")
	}

	if mmCreateAuthor.defaultExpectation == nil {
		mmCreateAuthor.defaultExpectation = &AuthorDTOMockCreateAuthorExpectation{}
	}

	if mmCreateAuthor.defaultExpectation.params != nil {
		mmCreateAuthor.mock.t.Fatalf("AuthorDTOMock.CreateAuthor mock is already set by Expect")
	}

	if mmCreateAuthor.defaultExpectation.paramPtrs == nil {
		mmCreateAuthor.defaultExpectation.paramPtrs = &AuthorDTOMockCreateAuthorParamPtrs{}
	}
	mmCreateAuthor.defaultExpectation.paramPtrs.author = &author

	return mmCreateAuthor
}

// Inspect accepts an inspector function that has same arguments as the AuthorDTO.CreateAuthor
func (mmCreateAuthor *mAuthorDTOMockCreateAuthor) Inspect(f func(ctx context.Context, author *models.Author)) *mAuthorDTOMockCreateAuthor {
	if mmCreateAuthor.mock.inspectFuncCreateAuthor != nil {
		mmCreateAuthor.mock.t.Fatalf("Inspect function is already set for AuthorDTOMock.CreateAuthor")
	}

	mmCreateAuthor.mock.inspectFuncCreateAuthor = f

	return mmCreateAuthor
}

// Return sets up results that will be returned by AuthorDTO.CreateAuthor
func (mmCreateAuthor *mAuthorDTOMockCreateAuthor) Return(ap1 *models.Author, err error) *AuthorDTOMock {
	if mmCreateAuthor.mock.funcCreateAuthor != nil {
		mmCreateAuthor.mock.t.Fatalf("AuthorDTOMock.CreateAuthor mock is already set by Set")
	}

	if mmCreateAuthor.defaultExpectation == nil {
		mmCreateAuthor.defaultExpectation = &AuthorDTOMockCreateAuthorExpectation{mock: mmCreateAuthor.mock}
	}
	mmCreateAuthor.defaultExpectation.results = &AuthorDTOMockCreateAuthorResults{ap1, err}
	return mmCreateAuthor.mock
}

// Set uses given function f to mock the AuthorDTO.CreateAuthor method
func (mmCreateAuthor *mAuthorDTOMockCreateAuthor) Set(f func(ctx context.Context, author *models.Author) (ap1 *models.Author, err error)) *AuthorDTOMock {
	if mmCreateAuthor.defaultExpectation != nil {
		mmCreateAuthor.mock.t.Fatalf("Default expectation is already set for the AuthorDTO.CreateAuthor method")
	}

	if len(mmCreateAuthor.expectations) > 0 {
		mmCreateAuthor.mock.t.Fatalf("Some expectations are already set for the AuthorDTO.CreateAuthor method")
	}

	mmCreateAuthor.mock.funcCreateAuthor = f
	return mmCreateAuthor.mock
}

// When sets expectation for the AuthorDTO.CreateAuthor which will trigger the result defined by the following
// Then helper
func (mmCreateAuthor *mAuthorDTOMockCreateAuthor) When(ctx context.Context, author *models.Author) *AuthorDTOMockCreateAuthorExpectation {
	if mmCreateAuthor.mock.funcCreateAuthor != nil {
		mmCreateAuthor.mock.t.Fatalf("AuthorDTOMock.CreateAuthor mock is already set by Set")
	}

	expectation := &AuthorDTOMockCreateAuthorExpectation{
		mock:   mmCreateAuthor.mock,
		params: &AuthorDTOMockCreateAuthorParams{ctx, author},
	}
	mmCreateAuthor.expectations = append(mmCreateAuthor.expectations, expectation)
	return expectation
}

// Then sets up AuthorDTO.CreateAuthor return parameters for the expectation previously defined by the When method
func (e *AuthorDTOMockCreateAuthorExpectation) Then(ap1 *models.Author, err error) *AuthorDTOMock {
	e.results = &AuthorDTOMockCreateAuthorResults{ap1, err}
	return e.mock
}

// Times sets number of times AuthorDTO.CreateAuthor should be invoked
func (mmCreateAuthor *mAuthorDTOMockCreateAuthor) Times(n uint64) *mAuthorDTOMockCreateAuthor {
	if n == 0 {
		mmCreateAuthor.mock.t.Fatalf("Times of AuthorDTOMock.CreateAuthor mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateAuthor.expectedInvocations, n)
	return mmCreateAuthor
}

func (mmCreateAuthor *mAuthorDTOMockCreateAuthor) invocationsDone() bool {
	if len(mmCreateAuthor.expectations) == 0 && mmCreateAuthor.defaultExpectation == nil && mmCreateAuthor.mock.funcCreateAuthor == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateAuthor.mock.afterCreateAuthorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateAuthor.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateAuthor implements AuthorDTO
func (mmCreateAuthor *AuthorDTOMock) CreateAuthor(ctx context.Context, author *models.Author) (ap1 *models.Author, err error) {
	mm_atomic.AddUint64(&mmCreateAuthor.beforeCreateAuthorCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateAuthor.afterCreateAuthorCounter, 1)

	if mmCreateAuthor.inspectFuncCreateAuthor != nil {
		mmCreateAuthor.inspectFuncCreateAuthor(ctx, author)
	}

	mm_params := AuthorDTOMockCreateAuthorParams{ctx, author}

	// Record call args
	mmCreateAuthor.CreateAuthorMock.mutex.Lock()
	mmCreateAuthor.CreateAuthorMock.callArgs = append(mmCreateAuthor.CreateAuthorMock.callArgs, &mm_params)
	mmCreateAuthor.CreateAuthorMock.mutex.Unlock()

	for _, e := range mmCreateAuthor.CreateAuthorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmCreateAuthor.CreateAuthorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateAuthor.CreateAuthorMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateAuthor.CreateAuthorMock.defaultExpectation.params
		mm_want_ptrs := mmCreateAuthor.CreateAuthorMock.defaultExpectation.paramPtrs

		mm_got := AuthorDTOMockCreateAuthorParams{ctx, author}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateAuthor.t.Errorf("AuthorDTOMock.CreateAuthor got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.author != nil && !minimock.Equal(*mm_want_ptrs.author, mm_got.author) {
				mmCreateAuthor.t.Errorf("AuthorDTOMock.CreateAuthor got unexpected parameter author, want: %#v, got: %#v%s\n", *mm_want_ptrs.author, mm_got.author, minimock.Diff(*mm_want_ptrs.author, mm_got.author))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateAuthor.t.Errorf("AuthorDTOMock.CreateAuthor got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateAuthor.CreateAuthorMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateAuthor.t.Fatal("No results are set for the AuthorDTOMock.CreateAuthor")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmCreateAuthor.funcCreateAuthor != nil {
		return mmCreateAuthor.funcCreateAuthor(ctx, author)
	}
	mmCreateAuthor.t.Fatalf("Unexpected call to AuthorDTOMock.CreateAuthor. %v %v", ctx, author)
	return
}

// CreateAuthorAfterCounter returns a count of finished AuthorDTOMock.CreateAuthor invocations
func (mmCreateAuthor *AuthorDTOMock) CreateAuthorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAuthor.afterCreateAuthorCounter)
}

// CreateAuthorBeforeCounter returns a count of AuthorDTOMock.CreateAuthor invocations
func (mmCreateAuthor *AuthorDTOMock) CreateAuthorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateAuthor.beforeCreateAuthorCounter)
}

// Calls returns a list of arguments used in each call to AuthorDTOMock.CreateAuthor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateAuthor *mAuthorDTOMockCreateAuthor) Calls() []*AuthorDTOMockCreateAuthorParams {
	mmCreateAuthor.mutex.RLock()

	argCopy := make([]*AuthorDTOMockCreateAuthorParams, len(mmCreateAuthor.callArgs))
	copy(argCopy, mmCreateAuthor.callArgs)

	mmCreateAuthor.mutex.RUnlock()

	return argCopy
}

// MinimockCreateAuthorDone returns true if the count of the CreateAuthor invocations corresponds
// the number of defined expectations
func (m *AuthorDTOMock) MinimockCreateAuthorDone() bool {
	if m.CreateAuthorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateAuthorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateAuthorMock.invocationsDone()
}

// MinimockCreateAuthorInspect logs each unmet expectation
func (m *AuthorDTOMock) MinimockCreateAuthorInspect() {
	for _, e := range m.CreateAuthorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthorDTOMock.CreateAuthor with params: %#v", *e.params)
		}
	}

	afterCreateAuthorCounter := mm_atomic.LoadUint64(&m.afterCreateAuthorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateAuthorMock.defaultExpectation != nil && afterCreateAuthorCounter < 1 {
		if m.CreateAuthorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthorDTOMock.CreateAuthor")
		} else {
			m.t.Errorf("Expected call to AuthorDTOMock.CreateAuthor with params: %#v", *m.CreateAuthorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateAuthor != nil && afterCreateAuthorCounter < 1 {
		m.t.Error("Expected call to AuthorDTOMock.CreateAuthor")
	}

	if !m.CreateAuthorMock.invocationsDone() && afterCreateAuthorCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthorDTOMock.CreateAuthor but found %d calls",
			mm_atomic.LoadUint64(&m.CreateAuthorMock.expectedInvocations), afterCreateAuthorCounter)
	}
}

type mAuthorDTOMockDeleteAuthor struct {
	optional           bool
	mock               *AuthorDTOMock
	defaultExpectation *AuthorDTOMockDeleteAuthorExpectation
	expectations       []*AuthorDTOMockDeleteAuthorExpectation

	callArgs []*AuthorDTOMockDeleteAuthorParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthorDTOMockDeleteAuthorExpectation specifies expectation struct of the AuthorDTO.DeleteAuthor
type AuthorDTOMockDeleteAuthorExpectation struct {
	mock      *AuthorDTOMock
	params    *AuthorDTOMockDeleteAuthorParams
	paramPtrs *AuthorDTOMockDeleteAuthorParamPtrs
	results   *AuthorDTOMockDeleteAuthorResults
	Counter   uint64
}

// AuthorDTOMockDeleteAuthorParams contains parameters of the AuthorDTO.DeleteAuthor
type AuthorDTOMockDeleteAuthorParams struct {
	ctx       context.Context
	author_id int
}

// AuthorDTOMockDeleteAuthorParamPtrs contains pointers to parameters of the AuthorDTO.DeleteAuthor
type AuthorDTOMockDeleteAuthorParamPtrs struct {
	ctx       *context.Context
	author_id *int
}

// AuthorDTOMockDeleteAuthorResults contains results of the AuthorDTO.DeleteAuthor
type AuthorDTOMockDeleteAuthorResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteAuthor *mAuthorDTOMockDeleteAuthor) Optional() *mAuthorDTOMockDeleteAuthor {
	mmDeleteAuthor.optional = true
	return mmDeleteAuthor
}

// Expect sets up expected params for AuthorDTO.DeleteAuthor
func (mmDeleteAuthor *mAuthorDTOMockDeleteAuthor) Expect(ctx context.Context, author_id int) *mAuthorDTOMockDeleteAuthor {
	if mmDeleteAuthor.mock.funcDeleteAuthor != nil {
		mmDeleteAuthor.mock.t.Fatalf("AuthorDTOMock.DeleteAuthor mock is already set by Set")
	}

	if mmDeleteAuthor.defaultExpectation == nil {
		mmDeleteAuthor.defaultExpectation = &AuthorDTOMockDeleteAuthorExpectation{}
	}

	if mmDeleteAuthor.defaultExpectation.paramPtrs != nil {
		mmDeleteAuthor.mock.t.Fatalf("AuthorDTOMock.DeleteAuthor mock is already set by ExpectParams functions")
	}

	mmDeleteAuthor.defaultExpectation.params = &AuthorDTOMockDeleteAuthorParams{ctx, author_id}
	for _, e := range mmDeleteAuthor.expectations {
		if minimock.Equal(e.params, mmDeleteAuthor.defaultExpectation.params) {
			mmDeleteAuthor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteAuthor.defaultExpectation.params)
		}
	}

	return mmDeleteAuthor
}

// ExpectCtxParam1 sets up expected param ctx for AuthorDTO.DeleteAuthor
func (mmDeleteAuthor *mAuthorDTOMockDeleteAuthor) ExpectCtxParam1(ctx context.Context) *mAuthorDTOMockDeleteAuthor {
	if mmDeleteAuthor.mock.funcDeleteAuthor != nil {
		mmDeleteAuthor.mock.t.Fatalf("AuthorDTOMock.DeleteAuthor mock is already set by Set")
	}

	if mmDeleteAuthor.defaultExpectation == nil {
		mmDeleteAuthor.defaultExpectation = &AuthorDTOMockDeleteAuthorExpectation{}
	}

	if mmDeleteAuthor.defaultExpectation.params != nil {
		mmDeleteAuthor.mock.t.Fatalf("AuthorDTOMock.DeleteAuthor mock is already set by Expect")
	}

	if mmDeleteAuthor.defaultExpectation.paramPtrs == nil {
		mmDeleteAuthor.defaultExpectation.paramPtrs = &AuthorDTOMockDeleteAuthorParamPtrs{}
	}
	mmDeleteAuthor.defaultExpectation.paramPtrs.ctx = &ctx

	return mmDeleteAuthor
}

// ExpectAuthor_idParam2 sets up expected param author_id for AuthorDTO.DeleteAuthor
func (mmDeleteAuthor *mAuthorDTOMockDeleteAuthor) ExpectAuthor_idParam2(author_id int) *mAuthorDTOMockDeleteAuthor {
	if mmDeleteAuthor.mock.funcDeleteAuthor != nil {
		mmDeleteAuthor.mock.t.Fatalf("AuthorDTOMock.DeleteAuthor mock is already set by Set")
	}

	if mmDeleteAuthor.defaultExpectation == nil {
		mmDeleteAuthor.defaultExpectation = &AuthorDTOMockDeleteAuthorExpectation{}
	}

	if mmDeleteAuthor.defaultExpectation.params != nil {
		mmDeleteAuthor.mock.t.Fatalf("AuthorDTOMock.DeleteAuthor mock is already set by Expect")
	}

	if mmDeleteAuthor.defaultExpectation.paramPtrs == nil {
		mmDeleteAuthor.defaultExpectation.paramPtrs = &AuthorDTOMockDeleteAuthorParamPtrs{}
	}
	mmDeleteAuthor.defaultExpectation.paramPtrs.author_id = &author_id

	return mmDeleteAuthor
}

// Inspect accepts an inspector function that has same arguments as the AuthorDTO.DeleteAuthor
func (mmDeleteAuthor *mAuthorDTOMockDeleteAuthor) Inspect(f func(ctx context.Context, author_id int)) *mAuthorDTOMockDeleteAuthor {
	if mmDeleteAuthor.mock.inspectFuncDeleteAuthor != nil {
		mmDeleteAuthor.mock.t.Fatalf("Inspect function is already set for AuthorDTOMock.DeleteAuthor")
	}

	mmDeleteAuthor.mock.inspectFuncDeleteAuthor = f

	return mmDeleteAuthor
}

// Return sets up results that will be returned by AuthorDTO.DeleteAuthor
func (mmDeleteAuthor *mAuthorDTOMockDeleteAuthor) Return(s1 string, err error) *AuthorDTOMock {
	if mmDeleteAuthor.mock.funcDeleteAuthor != nil {
		mmDeleteAuthor.mock.t.Fatalf("AuthorDTOMock.DeleteAuthor mock is already set by Set")
	}

	if mmDeleteAuthor.defaultExpectation == nil {
		mmDeleteAuthor.defaultExpectation = &AuthorDTOMockDeleteAuthorExpectation{mock: mmDeleteAuthor.mock}
	}
	mmDeleteAuthor.defaultExpectation.results = &AuthorDTOMockDeleteAuthorResults{s1, err}
	return mmDeleteAuthor.mock
}

// Set uses given function f to mock the AuthorDTO.DeleteAuthor method
func (mmDeleteAuthor *mAuthorDTOMockDeleteAuthor) Set(f func(ctx context.Context, author_id int) (s1 string, err error)) *AuthorDTOMock {
	if mmDeleteAuthor.defaultExpectation != nil {
		mmDeleteAuthor.mock.t.Fatalf("Default expectation is already set for the AuthorDTO.DeleteAuthor method")
	}

	if len(mmDeleteAuthor.expectations) > 0 {
		mmDeleteAuthor.mock.t.Fatalf("Some expectations are already set for the AuthorDTO.DeleteAuthor method")
	}

	mmDeleteAuthor.mock.funcDeleteAuthor = f
	return mmDeleteAuthor.mock
}

// When sets expectation for the AuthorDTO.DeleteAuthor which will trigger the result defined by the following
// Then helper
func (mmDeleteAuthor *mAuthorDTOMockDeleteAuthor) When(ctx context.Context, author_id int) *AuthorDTOMockDeleteAuthorExpectation {
	if mmDeleteAuthor.mock.funcDeleteAuthor != nil {
		mmDeleteAuthor.mock.t.Fatalf("AuthorDTOMock.DeleteAuthor mock is already set by Set")
	}

	expectation := &AuthorDTOMockDeleteAuthorExpectation{
		mock:   mmDeleteAuthor.mock,
		params: &AuthorDTOMockDeleteAuthorParams{ctx, author_id},
	}
	mmDeleteAuthor.expectations = append(mmDeleteAuthor.expectations, expectation)
	return expectation
}

// Then sets up AuthorDTO.DeleteAuthor return parameters for the expectation previously defined by the When method
func (e *AuthorDTOMockDeleteAuthorExpectation) Then(s1 string, err error) *AuthorDTOMock {
	e.results = &AuthorDTOMockDeleteAuthorResults{s1, err}
	return e.mock
}

// Times sets number of times AuthorDTO.DeleteAuthor should be invoked
func (mmDeleteAuthor *mAuthorDTOMockDeleteAuthor) Times(n uint64) *mAuthorDTOMockDeleteAuthor {
	if n == 0 {
		mmDeleteAuthor.mock.t.Fatalf("Times of AuthorDTOMock.DeleteAuthor mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteAuthor.expectedInvocations, n)
	return mmDeleteAuthor
}

func (mmDeleteAuthor *mAuthorDTOMockDeleteAuthor) invocationsDone() bool {
	if len(mmDeleteAuthor.expectations) == 0 && mmDeleteAuthor.defaultExpectation == nil && mmDeleteAuthor.mock.funcDeleteAuthor == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteAuthor.mock.afterDeleteAuthorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteAuthor.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteAuthor implements AuthorDTO
func (mmDeleteAuthor *AuthorDTOMock) DeleteAuthor(ctx context.Context, author_id int) (s1 string, err error) {
	mm_atomic.AddUint64(&mmDeleteAuthor.beforeDeleteAuthorCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteAuthor.afterDeleteAuthorCounter, 1)

	if mmDeleteAuthor.inspectFuncDeleteAuthor != nil {
		mmDeleteAuthor.inspectFuncDeleteAuthor(ctx, author_id)
	}

	mm_params := AuthorDTOMockDeleteAuthorParams{ctx, author_id}

	// Record call args
	mmDeleteAuthor.DeleteAuthorMock.mutex.Lock()
	mmDeleteAuthor.DeleteAuthorMock.callArgs = append(mmDeleteAuthor.DeleteAuthorMock.callArgs, &mm_params)
	mmDeleteAuthor.DeleteAuthorMock.mutex.Unlock()

	for _, e := range mmDeleteAuthor.DeleteAuthorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmDeleteAuthor.DeleteAuthorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteAuthor.DeleteAuthorMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteAuthor.DeleteAuthorMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteAuthor.DeleteAuthorMock.defaultExpectation.paramPtrs

		mm_got := AuthorDTOMockDeleteAuthorParams{ctx, author_id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteAuthor.t.Errorf("AuthorDTOMock.DeleteAuthor got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.author_id != nil && !minimock.Equal(*mm_want_ptrs.author_id, mm_got.author_id) {
				mmDeleteAuthor.t.Errorf("AuthorDTOMock.DeleteAuthor got unexpected parameter author_id, want: %#v, got: %#v%s\n", *mm_want_ptrs.author_id, mm_got.author_id, minimock.Diff(*mm_want_ptrs.author_id, mm_got.author_id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteAuthor.t.Errorf("AuthorDTOMock.DeleteAuthor got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteAuthor.DeleteAuthorMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteAuthor.t.Fatal("No results are set for the AuthorDTOMock.DeleteAuthor")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmDeleteAuthor.funcDeleteAuthor != nil {
		return mmDeleteAuthor.funcDeleteAuthor(ctx, author_id)
	}
	mmDeleteAuthor.t.Fatalf("Unexpected call to AuthorDTOMock.DeleteAuthor. %v %v", ctx, author_id)
	return
}

// DeleteAuthorAfterCounter returns a count of finished AuthorDTOMock.DeleteAuthor invocations
func (mmDeleteAuthor *AuthorDTOMock) DeleteAuthorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAuthor.afterDeleteAuthorCounter)
}

// DeleteAuthorBeforeCounter returns a count of AuthorDTOMock.DeleteAuthor invocations
func (mmDeleteAuthor *AuthorDTOMock) DeleteAuthorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteAuthor.beforeDeleteAuthorCounter)
}

// Calls returns a list of arguments used in each call to AuthorDTOMock.DeleteAuthor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteAuthor *mAuthorDTOMockDeleteAuthor) Calls() []*AuthorDTOMockDeleteAuthorParams {
	mmDeleteAuthor.mutex.RLock()

	argCopy := make([]*AuthorDTOMockDeleteAuthorParams, len(mmDeleteAuthor.callArgs))
	copy(argCopy, mmDeleteAuthor.callArgs)

	mmDeleteAuthor.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteAuthorDone returns true if the count of the DeleteAuthor invocations corresponds
// the number of defined expectations
func (m *AuthorDTOMock) MinimockDeleteAuthorDone() bool {
	if m.DeleteAuthorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteAuthorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteAuthorMock.invocationsDone()
}

// MinimockDeleteAuthorInspect logs each unmet expectation
func (m *AuthorDTOMock) MinimockDeleteAuthorInspect() {
	for _, e := range m.DeleteAuthorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthorDTOMock.DeleteAuthor with params: %#v", *e.params)
		}
	}

	afterDeleteAuthorCounter := mm_atomic.LoadUint64(&m.afterDeleteAuthorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteAuthorMock.defaultExpectation != nil && afterDeleteAuthorCounter < 1 {
		if m.DeleteAuthorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthorDTOMock.DeleteAuthor")
		} else {
			m.t.Errorf("Expected call to AuthorDTOMock.DeleteAuthor with params: %#v", *m.DeleteAuthorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteAuthor != nil && afterDeleteAuthorCounter < 1 {
		m.t.Error("Expected call to AuthorDTOMock.DeleteAuthor")
	}

	if !m.DeleteAuthorMock.invocationsDone() && afterDeleteAuthorCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthorDTOMock.DeleteAuthor but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteAuthorMock.expectedInvocations), afterDeleteAuthorCounter)
	}
}

type mAuthorDTOMockGetAllAuthor struct {
	optional           bool
	mock               *AuthorDTOMock
	defaultExpectation *AuthorDTOMockGetAllAuthorExpectation
	expectations       []*AuthorDTOMockGetAllAuthorExpectation

	callArgs []*AuthorDTOMockGetAllAuthorParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthorDTOMockGetAllAuthorExpectation specifies expectation struct of the AuthorDTO.GetAllAuthor
type AuthorDTOMockGetAllAuthorExpectation struct {
	mock      *AuthorDTOMock
	params    *AuthorDTOMockGetAllAuthorParams
	paramPtrs *AuthorDTOMockGetAllAuthorParamPtrs
	results   *AuthorDTOMockGetAllAuthorResults
	Counter   uint64
}

// AuthorDTOMockGetAllAuthorParams contains parameters of the AuthorDTO.GetAllAuthor
type AuthorDTOMockGetAllAuthorParams struct {
	ctx        context.Context
	pagination models.PaginationForAuthor
}

// AuthorDTOMockGetAllAuthorParamPtrs contains pointers to parameters of the AuthorDTO.GetAllAuthor
type AuthorDTOMockGetAllAuthorParamPtrs struct {
	ctx        *context.Context
	pagination *models.PaginationForAuthor
}

// AuthorDTOMockGetAllAuthorResults contains results of the AuthorDTO.GetAllAuthor
type AuthorDTOMockGetAllAuthorResults struct {
	apa1 []*models.Author
	err  error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAllAuthor *mAuthorDTOMockGetAllAuthor) Optional() *mAuthorDTOMockGetAllAuthor {
	mmGetAllAuthor.optional = true
	return mmGetAllAuthor
}

// Expect sets up expected params for AuthorDTO.GetAllAuthor
func (mmGetAllAuthor *mAuthorDTOMockGetAllAuthor) Expect(ctx context.Context, pagination models.PaginationForAuthor) *mAuthorDTOMockGetAllAuthor {
	if mmGetAllAuthor.mock.funcGetAllAuthor != nil {
		mmGetAllAuthor.mock.t.Fatalf("AuthorDTOMock.GetAllAuthor mock is already set by Set")
	}

	if mmGetAllAuthor.defaultExpectation == nil {
		mmGetAllAuthor.defaultExpectation = &AuthorDTOMockGetAllAuthorExpectation{}
	}

	if mmGetAllAuthor.defaultExpectation.paramPtrs != nil {
		mmGetAllAuthor.mock.t.Fatalf("AuthorDTOMock.GetAllAuthor mock is already set by ExpectParams functions")
	}

	mmGetAllAuthor.defaultExpectation.params = &AuthorDTOMockGetAllAuthorParams{ctx, pagination}
	for _, e := range mmGetAllAuthor.expectations {
		if minimock.Equal(e.params, mmGetAllAuthor.defaultExpectation.params) {
			mmGetAllAuthor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAllAuthor.defaultExpectation.params)
		}
	}

	return mmGetAllAuthor
}

// ExpectCtxParam1 sets up expected param ctx for AuthorDTO.GetAllAuthor
func (mmGetAllAuthor *mAuthorDTOMockGetAllAuthor) ExpectCtxParam1(ctx context.Context) *mAuthorDTOMockGetAllAuthor {
	if mmGetAllAuthor.mock.funcGetAllAuthor != nil {
		mmGetAllAuthor.mock.t.Fatalf("AuthorDTOMock.GetAllAuthor mock is already set by Set")
	}

	if mmGetAllAuthor.defaultExpectation == nil {
		mmGetAllAuthor.defaultExpectation = &AuthorDTOMockGetAllAuthorExpectation{}
	}

	if mmGetAllAuthor.defaultExpectation.params != nil {
		mmGetAllAuthor.mock.t.Fatalf("AuthorDTOMock.GetAllAuthor mock is already set by Expect")
	}

	if mmGetAllAuthor.defaultExpectation.paramPtrs == nil {
		mmGetAllAuthor.defaultExpectation.paramPtrs = &AuthorDTOMockGetAllAuthorParamPtrs{}
	}
	mmGetAllAuthor.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetAllAuthor
}

// ExpectPaginationParam2 sets up expected param pagination for AuthorDTO.GetAllAuthor
func (mmGetAllAuthor *mAuthorDTOMockGetAllAuthor) ExpectPaginationParam2(pagination models.PaginationForAuthor) *mAuthorDTOMockGetAllAuthor {
	if mmGetAllAuthor.mock.funcGetAllAuthor != nil {
		mmGetAllAuthor.mock.t.Fatalf("AuthorDTOMock.GetAllAuthor mock is already set by Set")
	}

	if mmGetAllAuthor.defaultExpectation == nil {
		mmGetAllAuthor.defaultExpectation = &AuthorDTOMockGetAllAuthorExpectation{}
	}

	if mmGetAllAuthor.defaultExpectation.params != nil {
		mmGetAllAuthor.mock.t.Fatalf("AuthorDTOMock.GetAllAuthor mock is already set by Expect")
	}

	if mmGetAllAuthor.defaultExpectation.paramPtrs == nil {
		mmGetAllAuthor.defaultExpectation.paramPtrs = &AuthorDTOMockGetAllAuthorParamPtrs{}
	}
	mmGetAllAuthor.defaultExpectation.paramPtrs.pagination = &pagination

	return mmGetAllAuthor
}

// Inspect accepts an inspector function that has same arguments as the AuthorDTO.GetAllAuthor
func (mmGetAllAuthor *mAuthorDTOMockGetAllAuthor) Inspect(f func(ctx context.Context, pagination models.PaginationForAuthor)) *mAuthorDTOMockGetAllAuthor {
	if mmGetAllAuthor.mock.inspectFuncGetAllAuthor != nil {
		mmGetAllAuthor.mock.t.Fatalf("Inspect function is already set for AuthorDTOMock.GetAllAuthor")
	}

	mmGetAllAuthor.mock.inspectFuncGetAllAuthor = f

	return mmGetAllAuthor
}

// Return sets up results that will be returned by AuthorDTO.GetAllAuthor
func (mmGetAllAuthor *mAuthorDTOMockGetAllAuthor) Return(apa1 []*models.Author, err error) *AuthorDTOMock {
	if mmGetAllAuthor.mock.funcGetAllAuthor != nil {
		mmGetAllAuthor.mock.t.Fatalf("AuthorDTOMock.GetAllAuthor mock is already set by Set")
	}

	if mmGetAllAuthor.defaultExpectation == nil {
		mmGetAllAuthor.defaultExpectation = &AuthorDTOMockGetAllAuthorExpectation{mock: mmGetAllAuthor.mock}
	}
	mmGetAllAuthor.defaultExpectation.results = &AuthorDTOMockGetAllAuthorResults{apa1, err}
	return mmGetAllAuthor.mock
}

// Set uses given function f to mock the AuthorDTO.GetAllAuthor method
func (mmGetAllAuthor *mAuthorDTOMockGetAllAuthor) Set(f func(ctx context.Context, pagination models.PaginationForAuthor) (apa1 []*models.Author, err error)) *AuthorDTOMock {
	if mmGetAllAuthor.defaultExpectation != nil {
		mmGetAllAuthor.mock.t.Fatalf("Default expectation is already set for the AuthorDTO.GetAllAuthor method")
	}

	if len(mmGetAllAuthor.expectations) > 0 {
		mmGetAllAuthor.mock.t.Fatalf("Some expectations are already set for the AuthorDTO.GetAllAuthor method")
	}

	mmGetAllAuthor.mock.funcGetAllAuthor = f
	return mmGetAllAuthor.mock
}

// When sets expectation for the AuthorDTO.GetAllAuthor which will trigger the result defined by the following
// Then helper
func (mmGetAllAuthor *mAuthorDTOMockGetAllAuthor) When(ctx context.Context, pagination models.PaginationForAuthor) *AuthorDTOMockGetAllAuthorExpectation {
	if mmGetAllAuthor.mock.funcGetAllAuthor != nil {
		mmGetAllAuthor.mock.t.Fatalf("AuthorDTOMock.GetAllAuthor mock is already set by Set")
	}

	expectation := &AuthorDTOMockGetAllAuthorExpectation{
		mock:   mmGetAllAuthor.mock,
		params: &AuthorDTOMockGetAllAuthorParams{ctx, pagination},
	}
	mmGetAllAuthor.expectations = append(mmGetAllAuthor.expectations, expectation)
	return expectation
}

// Then sets up AuthorDTO.GetAllAuthor return parameters for the expectation previously defined by the When method
func (e *AuthorDTOMockGetAllAuthorExpectation) Then(apa1 []*models.Author, err error) *AuthorDTOMock {
	e.results = &AuthorDTOMockGetAllAuthorResults{apa1, err}
	return e.mock
}

// Times sets number of times AuthorDTO.GetAllAuthor should be invoked
func (mmGetAllAuthor *mAuthorDTOMockGetAllAuthor) Times(n uint64) *mAuthorDTOMockGetAllAuthor {
	if n == 0 {
		mmGetAllAuthor.mock.t.Fatalf("Times of AuthorDTOMock.GetAllAuthor mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAllAuthor.expectedInvocations, n)
	return mmGetAllAuthor
}

func (mmGetAllAuthor *mAuthorDTOMockGetAllAuthor) invocationsDone() bool {
	if len(mmGetAllAuthor.expectations) == 0 && mmGetAllAuthor.defaultExpectation == nil && mmGetAllAuthor.mock.funcGetAllAuthor == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAllAuthor.mock.afterGetAllAuthorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAllAuthor.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAllAuthor implements AuthorDTO
func (mmGetAllAuthor *AuthorDTOMock) GetAllAuthor(ctx context.Context, pagination models.PaginationForAuthor) (apa1 []*models.Author, err error) {
	mm_atomic.AddUint64(&mmGetAllAuthor.beforeGetAllAuthorCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAllAuthor.afterGetAllAuthorCounter, 1)

	if mmGetAllAuthor.inspectFuncGetAllAuthor != nil {
		mmGetAllAuthor.inspectFuncGetAllAuthor(ctx, pagination)
	}

	mm_params := AuthorDTOMockGetAllAuthorParams{ctx, pagination}

	// Record call args
	mmGetAllAuthor.GetAllAuthorMock.mutex.Lock()
	mmGetAllAuthor.GetAllAuthorMock.callArgs = append(mmGetAllAuthor.GetAllAuthorMock.callArgs, &mm_params)
	mmGetAllAuthor.GetAllAuthorMock.mutex.Unlock()

	for _, e := range mmGetAllAuthor.GetAllAuthorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.apa1, e.results.err
		}
	}

	if mmGetAllAuthor.GetAllAuthorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAllAuthor.GetAllAuthorMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAllAuthor.GetAllAuthorMock.defaultExpectation.params
		mm_want_ptrs := mmGetAllAuthor.GetAllAuthorMock.defaultExpectation.paramPtrs

		mm_got := AuthorDTOMockGetAllAuthorParams{ctx, pagination}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAllAuthor.t.Errorf("AuthorDTOMock.GetAllAuthor got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pagination != nil && !minimock.Equal(*mm_want_ptrs.pagination, mm_got.pagination) {
				mmGetAllAuthor.t.Errorf("AuthorDTOMock.GetAllAuthor got unexpected parameter pagination, want: %#v, got: %#v%s\n", *mm_want_ptrs.pagination, mm_got.pagination, minimock.Diff(*mm_want_ptrs.pagination, mm_got.pagination))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAllAuthor.t.Errorf("AuthorDTOMock.GetAllAuthor got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAllAuthor.GetAllAuthorMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAllAuthor.t.Fatal("No results are set for the AuthorDTOMock.GetAllAuthor")
		}
		return (*mm_results).apa1, (*mm_results).err
	}
	if mmGetAllAuthor.funcGetAllAuthor != nil {
		return mmGetAllAuthor.funcGetAllAuthor(ctx, pagination)
	}
	mmGetAllAuthor.t.Fatalf("Unexpected call to AuthorDTOMock.GetAllAuthor. %v %v", ctx, pagination)
	return
}

// GetAllAuthorAfterCounter returns a count of finished AuthorDTOMock.GetAllAuthor invocations
func (mmGetAllAuthor *AuthorDTOMock) GetAllAuthorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllAuthor.afterGetAllAuthorCounter)
}

// GetAllAuthorBeforeCounter returns a count of AuthorDTOMock.GetAllAuthor invocations
func (mmGetAllAuthor *AuthorDTOMock) GetAllAuthorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAllAuthor.beforeGetAllAuthorCounter)
}

// Calls returns a list of arguments used in each call to AuthorDTOMock.GetAllAuthor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAllAuthor *mAuthorDTOMockGetAllAuthor) Calls() []*AuthorDTOMockGetAllAuthorParams {
	mmGetAllAuthor.mutex.RLock()

	argCopy := make([]*AuthorDTOMockGetAllAuthorParams, len(mmGetAllAuthor.callArgs))
	copy(argCopy, mmGetAllAuthor.callArgs)

	mmGetAllAuthor.mutex.RUnlock()

	return argCopy
}

// MinimockGetAllAuthorDone returns true if the count of the GetAllAuthor invocations corresponds
// the number of defined expectations
func (m *AuthorDTOMock) MinimockGetAllAuthorDone() bool {
	if m.GetAllAuthorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAllAuthorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAllAuthorMock.invocationsDone()
}

// MinimockGetAllAuthorInspect logs each unmet expectation
func (m *AuthorDTOMock) MinimockGetAllAuthorInspect() {
	for _, e := range m.GetAllAuthorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthorDTOMock.GetAllAuthor with params: %#v", *e.params)
		}
	}

	afterGetAllAuthorCounter := mm_atomic.LoadUint64(&m.afterGetAllAuthorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAllAuthorMock.defaultExpectation != nil && afterGetAllAuthorCounter < 1 {
		if m.GetAllAuthorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthorDTOMock.GetAllAuthor")
		} else {
			m.t.Errorf("Expected call to AuthorDTOMock.GetAllAuthor with params: %#v", *m.GetAllAuthorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAllAuthor != nil && afterGetAllAuthorCounter < 1 {
		m.t.Error("Expected call to AuthorDTOMock.GetAllAuthor")
	}

	if !m.GetAllAuthorMock.invocationsDone() && afterGetAllAuthorCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthorDTOMock.GetAllAuthor but found %d calls",
			mm_atomic.LoadUint64(&m.GetAllAuthorMock.expectedInvocations), afterGetAllAuthorCounter)
	}
}

type mAuthorDTOMockGetAuthorByID struct {
	optional           bool
	mock               *AuthorDTOMock
	defaultExpectation *AuthorDTOMockGetAuthorByIDExpectation
	expectations       []*AuthorDTOMockGetAuthorByIDExpectation

	callArgs []*AuthorDTOMockGetAuthorByIDParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthorDTOMockGetAuthorByIDExpectation specifies expectation struct of the AuthorDTO.GetAuthorByID
type AuthorDTOMockGetAuthorByIDExpectation struct {
	mock      *AuthorDTOMock
	params    *AuthorDTOMockGetAuthorByIDParams
	paramPtrs *AuthorDTOMockGetAuthorByIDParamPtrs
	results   *AuthorDTOMockGetAuthorByIDResults
	Counter   uint64
}

// AuthorDTOMockGetAuthorByIDParams contains parameters of the AuthorDTO.GetAuthorByID
type AuthorDTOMockGetAuthorByIDParams struct {
	ctx       context.Context
	author_id int
}

// AuthorDTOMockGetAuthorByIDParamPtrs contains pointers to parameters of the AuthorDTO.GetAuthorByID
type AuthorDTOMockGetAuthorByIDParamPtrs struct {
	ctx       *context.Context
	author_id *int
}

// AuthorDTOMockGetAuthorByIDResults contains results of the AuthorDTO.GetAuthorByID
type AuthorDTOMockGetAuthorByIDResults struct {
	ap1 *models.Author
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetAuthorByID *mAuthorDTOMockGetAuthorByID) Optional() *mAuthorDTOMockGetAuthorByID {
	mmGetAuthorByID.optional = true
	return mmGetAuthorByID
}

// Expect sets up expected params for AuthorDTO.GetAuthorByID
func (mmGetAuthorByID *mAuthorDTOMockGetAuthorByID) Expect(ctx context.Context, author_id int) *mAuthorDTOMockGetAuthorByID {
	if mmGetAuthorByID.mock.funcGetAuthorByID != nil {
		mmGetAuthorByID.mock.t.Fatalf("AuthorDTOMock.GetAuthorByID mock is already set by Set")
	}

	if mmGetAuthorByID.defaultExpectation == nil {
		mmGetAuthorByID.defaultExpectation = &AuthorDTOMockGetAuthorByIDExpectation{}
	}

	if mmGetAuthorByID.defaultExpectation.paramPtrs != nil {
		mmGetAuthorByID.mock.t.Fatalf("AuthorDTOMock.GetAuthorByID mock is already set by ExpectParams functions")
	}

	mmGetAuthorByID.defaultExpectation.params = &AuthorDTOMockGetAuthorByIDParams{ctx, author_id}
	for _, e := range mmGetAuthorByID.expectations {
		if minimock.Equal(e.params, mmGetAuthorByID.defaultExpectation.params) {
			mmGetAuthorByID.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetAuthorByID.defaultExpectation.params)
		}
	}

	return mmGetAuthorByID
}

// ExpectCtxParam1 sets up expected param ctx for AuthorDTO.GetAuthorByID
func (mmGetAuthorByID *mAuthorDTOMockGetAuthorByID) ExpectCtxParam1(ctx context.Context) *mAuthorDTOMockGetAuthorByID {
	if mmGetAuthorByID.mock.funcGetAuthorByID != nil {
		mmGetAuthorByID.mock.t.Fatalf("AuthorDTOMock.GetAuthorByID mock is already set by Set")
	}

	if mmGetAuthorByID.defaultExpectation == nil {
		mmGetAuthorByID.defaultExpectation = &AuthorDTOMockGetAuthorByIDExpectation{}
	}

	if mmGetAuthorByID.defaultExpectation.params != nil {
		mmGetAuthorByID.mock.t.Fatalf("AuthorDTOMock.GetAuthorByID mock is already set by Expect")
	}

	if mmGetAuthorByID.defaultExpectation.paramPtrs == nil {
		mmGetAuthorByID.defaultExpectation.paramPtrs = &AuthorDTOMockGetAuthorByIDParamPtrs{}
	}
	mmGetAuthorByID.defaultExpectation.paramPtrs.ctx = &ctx

	return mmGetAuthorByID
}

// ExpectAuthor_idParam2 sets up expected param author_id for AuthorDTO.GetAuthorByID
func (mmGetAuthorByID *mAuthorDTOMockGetAuthorByID) ExpectAuthor_idParam2(author_id int) *mAuthorDTOMockGetAuthorByID {
	if mmGetAuthorByID.mock.funcGetAuthorByID != nil {
		mmGetAuthorByID.mock.t.Fatalf("AuthorDTOMock.GetAuthorByID mock is already set by Set")
	}

	if mmGetAuthorByID.defaultExpectation == nil {
		mmGetAuthorByID.defaultExpectation = &AuthorDTOMockGetAuthorByIDExpectation{}
	}

	if mmGetAuthorByID.defaultExpectation.params != nil {
		mmGetAuthorByID.mock.t.Fatalf("AuthorDTOMock.GetAuthorByID mock is already set by Expect")
	}

	if mmGetAuthorByID.defaultExpectation.paramPtrs == nil {
		mmGetAuthorByID.defaultExpectation.paramPtrs = &AuthorDTOMockGetAuthorByIDParamPtrs{}
	}
	mmGetAuthorByID.defaultExpectation.paramPtrs.author_id = &author_id

	return mmGetAuthorByID
}

// Inspect accepts an inspector function that has same arguments as the AuthorDTO.GetAuthorByID
func (mmGetAuthorByID *mAuthorDTOMockGetAuthorByID) Inspect(f func(ctx context.Context, author_id int)) *mAuthorDTOMockGetAuthorByID {
	if mmGetAuthorByID.mock.inspectFuncGetAuthorByID != nil {
		mmGetAuthorByID.mock.t.Fatalf("Inspect function is already set for AuthorDTOMock.GetAuthorByID")
	}

	mmGetAuthorByID.mock.inspectFuncGetAuthorByID = f

	return mmGetAuthorByID
}

// Return sets up results that will be returned by AuthorDTO.GetAuthorByID
func (mmGetAuthorByID *mAuthorDTOMockGetAuthorByID) Return(ap1 *models.Author, err error) *AuthorDTOMock {
	if mmGetAuthorByID.mock.funcGetAuthorByID != nil {
		mmGetAuthorByID.mock.t.Fatalf("AuthorDTOMock.GetAuthorByID mock is already set by Set")
	}

	if mmGetAuthorByID.defaultExpectation == nil {
		mmGetAuthorByID.defaultExpectation = &AuthorDTOMockGetAuthorByIDExpectation{mock: mmGetAuthorByID.mock}
	}
	mmGetAuthorByID.defaultExpectation.results = &AuthorDTOMockGetAuthorByIDResults{ap1, err}
	return mmGetAuthorByID.mock
}

// Set uses given function f to mock the AuthorDTO.GetAuthorByID method
func (mmGetAuthorByID *mAuthorDTOMockGetAuthorByID) Set(f func(ctx context.Context, author_id int) (ap1 *models.Author, err error)) *AuthorDTOMock {
	if mmGetAuthorByID.defaultExpectation != nil {
		mmGetAuthorByID.mock.t.Fatalf("Default expectation is already set for the AuthorDTO.GetAuthorByID method")
	}

	if len(mmGetAuthorByID.expectations) > 0 {
		mmGetAuthorByID.mock.t.Fatalf("Some expectations are already set for the AuthorDTO.GetAuthorByID method")
	}

	mmGetAuthorByID.mock.funcGetAuthorByID = f
	return mmGetAuthorByID.mock
}

// When sets expectation for the AuthorDTO.GetAuthorByID which will trigger the result defined by the following
// Then helper
func (mmGetAuthorByID *mAuthorDTOMockGetAuthorByID) When(ctx context.Context, author_id int) *AuthorDTOMockGetAuthorByIDExpectation {
	if mmGetAuthorByID.mock.funcGetAuthorByID != nil {
		mmGetAuthorByID.mock.t.Fatalf("AuthorDTOMock.GetAuthorByID mock is already set by Set")
	}

	expectation := &AuthorDTOMockGetAuthorByIDExpectation{
		mock:   mmGetAuthorByID.mock,
		params: &AuthorDTOMockGetAuthorByIDParams{ctx, author_id},
	}
	mmGetAuthorByID.expectations = append(mmGetAuthorByID.expectations, expectation)
	return expectation
}

// Then sets up AuthorDTO.GetAuthorByID return parameters for the expectation previously defined by the When method
func (e *AuthorDTOMockGetAuthorByIDExpectation) Then(ap1 *models.Author, err error) *AuthorDTOMock {
	e.results = &AuthorDTOMockGetAuthorByIDResults{ap1, err}
	return e.mock
}

// Times sets number of times AuthorDTO.GetAuthorByID should be invoked
func (mmGetAuthorByID *mAuthorDTOMockGetAuthorByID) Times(n uint64) *mAuthorDTOMockGetAuthorByID {
	if n == 0 {
		mmGetAuthorByID.mock.t.Fatalf("Times of AuthorDTOMock.GetAuthorByID mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetAuthorByID.expectedInvocations, n)
	return mmGetAuthorByID
}

func (mmGetAuthorByID *mAuthorDTOMockGetAuthorByID) invocationsDone() bool {
	if len(mmGetAuthorByID.expectations) == 0 && mmGetAuthorByID.defaultExpectation == nil && mmGetAuthorByID.mock.funcGetAuthorByID == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetAuthorByID.mock.afterGetAuthorByIDCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetAuthorByID.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetAuthorByID implements AuthorDTO
func (mmGetAuthorByID *AuthorDTOMock) GetAuthorByID(ctx context.Context, author_id int) (ap1 *models.Author, err error) {
	mm_atomic.AddUint64(&mmGetAuthorByID.beforeGetAuthorByIDCounter, 1)
	defer mm_atomic.AddUint64(&mmGetAuthorByID.afterGetAuthorByIDCounter, 1)

	if mmGetAuthorByID.inspectFuncGetAuthorByID != nil {
		mmGetAuthorByID.inspectFuncGetAuthorByID(ctx, author_id)
	}

	mm_params := AuthorDTOMockGetAuthorByIDParams{ctx, author_id}

	// Record call args
	mmGetAuthorByID.GetAuthorByIDMock.mutex.Lock()
	mmGetAuthorByID.GetAuthorByIDMock.callArgs = append(mmGetAuthorByID.GetAuthorByIDMock.callArgs, &mm_params)
	mmGetAuthorByID.GetAuthorByIDMock.mutex.Unlock()

	for _, e := range mmGetAuthorByID.GetAuthorByIDMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmGetAuthorByID.GetAuthorByIDMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetAuthorByID.GetAuthorByIDMock.defaultExpectation.Counter, 1)
		mm_want := mmGetAuthorByID.GetAuthorByIDMock.defaultExpectation.params
		mm_want_ptrs := mmGetAuthorByID.GetAuthorByIDMock.defaultExpectation.paramPtrs

		mm_got := AuthorDTOMockGetAuthorByIDParams{ctx, author_id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetAuthorByID.t.Errorf("AuthorDTOMock.GetAuthorByID got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.author_id != nil && !minimock.Equal(*mm_want_ptrs.author_id, mm_got.author_id) {
				mmGetAuthorByID.t.Errorf("AuthorDTOMock.GetAuthorByID got unexpected parameter author_id, want: %#v, got: %#v%s\n", *mm_want_ptrs.author_id, mm_got.author_id, minimock.Diff(*mm_want_ptrs.author_id, mm_got.author_id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetAuthorByID.t.Errorf("AuthorDTOMock.GetAuthorByID got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetAuthorByID.GetAuthorByIDMock.defaultExpectation.results
		if mm_results == nil {
			mmGetAuthorByID.t.Fatal("No results are set for the AuthorDTOMock.GetAuthorByID")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmGetAuthorByID.funcGetAuthorByID != nil {
		return mmGetAuthorByID.funcGetAuthorByID(ctx, author_id)
	}
	mmGetAuthorByID.t.Fatalf("Unexpected call to AuthorDTOMock.GetAuthorByID. %v %v", ctx, author_id)
	return
}

// GetAuthorByIDAfterCounter returns a count of finished AuthorDTOMock.GetAuthorByID invocations
func (mmGetAuthorByID *AuthorDTOMock) GetAuthorByIDAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthorByID.afterGetAuthorByIDCounter)
}

// GetAuthorByIDBeforeCounter returns a count of AuthorDTOMock.GetAuthorByID invocations
func (mmGetAuthorByID *AuthorDTOMock) GetAuthorByIDBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetAuthorByID.beforeGetAuthorByIDCounter)
}

// Calls returns a list of arguments used in each call to AuthorDTOMock.GetAuthorByID.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetAuthorByID *mAuthorDTOMockGetAuthorByID) Calls() []*AuthorDTOMockGetAuthorByIDParams {
	mmGetAuthorByID.mutex.RLock()

	argCopy := make([]*AuthorDTOMockGetAuthorByIDParams, len(mmGetAuthorByID.callArgs))
	copy(argCopy, mmGetAuthorByID.callArgs)

	mmGetAuthorByID.mutex.RUnlock()

	return argCopy
}

// MinimockGetAuthorByIDDone returns true if the count of the GetAuthorByID invocations corresponds
// the number of defined expectations
func (m *AuthorDTOMock) MinimockGetAuthorByIDDone() bool {
	if m.GetAuthorByIDMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetAuthorByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetAuthorByIDMock.invocationsDone()
}

// MinimockGetAuthorByIDInspect logs each unmet expectation
func (m *AuthorDTOMock) MinimockGetAuthorByIDInspect() {
	for _, e := range m.GetAuthorByIDMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthorDTOMock.GetAuthorByID with params: %#v", *e.params)
		}
	}

	afterGetAuthorByIDCounter := mm_atomic.LoadUint64(&m.afterGetAuthorByIDCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetAuthorByIDMock.defaultExpectation != nil && afterGetAuthorByIDCounter < 1 {
		if m.GetAuthorByIDMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthorDTOMock.GetAuthorByID")
		} else {
			m.t.Errorf("Expected call to AuthorDTOMock.GetAuthorByID with params: %#v", *m.GetAuthorByIDMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetAuthorByID != nil && afterGetAuthorByIDCounter < 1 {
		m.t.Error("Expected call to AuthorDTOMock.GetAuthorByID")
	}

	if !m.GetAuthorByIDMock.invocationsDone() && afterGetAuthorByIDCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthorDTOMock.GetAuthorByID but found %d calls",
			mm_atomic.LoadUint64(&m.GetAuthorByIDMock.expectedInvocations), afterGetAuthorByIDCounter)
	}
}

type mAuthorDTOMockUpdateAuthor struct {
	optional           bool
	mock               *AuthorDTOMock
	defaultExpectation *AuthorDTOMockUpdateAuthorExpectation
	expectations       []*AuthorDTOMockUpdateAuthorExpectation

	callArgs []*AuthorDTOMockUpdateAuthorParams
	mutex    sync.RWMutex

	expectedInvocations uint64
}

// AuthorDTOMockUpdateAuthorExpectation specifies expectation struct of the AuthorDTO.UpdateAuthor
type AuthorDTOMockUpdateAuthorExpectation struct {
	mock      *AuthorDTOMock
	params    *AuthorDTOMockUpdateAuthorParams
	paramPtrs *AuthorDTOMockUpdateAuthorParamPtrs
	results   *AuthorDTOMockUpdateAuthorResults
	Counter   uint64
}

// AuthorDTOMockUpdateAuthorParams contains parameters of the AuthorDTO.UpdateAuthor
type AuthorDTOMockUpdateAuthorParams struct {
	ctx       context.Context
	author_id int
	update    *models.UpdateInputAuthor
}

// AuthorDTOMockUpdateAuthorParamPtrs contains pointers to parameters of the AuthorDTO.UpdateAuthor
type AuthorDTOMockUpdateAuthorParamPtrs struct {
	ctx       *context.Context
	author_id *int
	update    **models.UpdateInputAuthor
}

// AuthorDTOMockUpdateAuthorResults contains results of the AuthorDTO.UpdateAuthor
type AuthorDTOMockUpdateAuthorResults struct {
	s1  string
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateAuthor *mAuthorDTOMockUpdateAuthor) Optional() *mAuthorDTOMockUpdateAuthor {
	mmUpdateAuthor.optional = true
	return mmUpdateAuthor
}

// Expect sets up expected params for AuthorDTO.UpdateAuthor
func (mmUpdateAuthor *mAuthorDTOMockUpdateAuthor) Expect(ctx context.Context, author_id int, update *models.UpdateInputAuthor) *mAuthorDTOMockUpdateAuthor {
	if mmUpdateAuthor.mock.funcUpdateAuthor != nil {
		mmUpdateAuthor.mock.t.Fatalf("AuthorDTOMock.UpdateAuthor mock is already set by Set")
	}

	if mmUpdateAuthor.defaultExpectation == nil {
		mmUpdateAuthor.defaultExpectation = &AuthorDTOMockUpdateAuthorExpectation{}
	}

	if mmUpdateAuthor.defaultExpectation.paramPtrs != nil {
		mmUpdateAuthor.mock.t.Fatalf("AuthorDTOMock.UpdateAuthor mock is already set by ExpectParams functions")
	}

	mmUpdateAuthor.defaultExpectation.params = &AuthorDTOMockUpdateAuthorParams{ctx, author_id, update}
	for _, e := range mmUpdateAuthor.expectations {
		if minimock.Equal(e.params, mmUpdateAuthor.defaultExpectation.params) {
			mmUpdateAuthor.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateAuthor.defaultExpectation.params)
		}
	}

	return mmUpdateAuthor
}

// ExpectCtxParam1 sets up expected param ctx for AuthorDTO.UpdateAuthor
func (mmUpdateAuthor *mAuthorDTOMockUpdateAuthor) ExpectCtxParam1(ctx context.Context) *mAuthorDTOMockUpdateAuthor {
	if mmUpdateAuthor.mock.funcUpdateAuthor != nil {
		mmUpdateAuthor.mock.t.Fatalf("AuthorDTOMock.UpdateAuthor mock is already set by Set")
	}

	if mmUpdateAuthor.defaultExpectation == nil {
		mmUpdateAuthor.defaultExpectation = &AuthorDTOMockUpdateAuthorExpectation{}
	}

	if mmUpdateAuthor.defaultExpectation.params != nil {
		mmUpdateAuthor.mock.t.Fatalf("AuthorDTOMock.UpdateAuthor mock is already set by Expect")
	}

	if mmUpdateAuthor.defaultExpectation.paramPtrs == nil {
		mmUpdateAuthor.defaultExpectation.paramPtrs = &AuthorDTOMockUpdateAuthorParamPtrs{}
	}
	mmUpdateAuthor.defaultExpectation.paramPtrs.ctx = &ctx

	return mmUpdateAuthor
}

// ExpectAuthor_idParam2 sets up expected param author_id for AuthorDTO.UpdateAuthor
func (mmUpdateAuthor *mAuthorDTOMockUpdateAuthor) ExpectAuthor_idParam2(author_id int) *mAuthorDTOMockUpdateAuthor {
	if mmUpdateAuthor.mock.funcUpdateAuthor != nil {
		mmUpdateAuthor.mock.t.Fatalf("AuthorDTOMock.UpdateAuthor mock is already set by Set")
	}

	if mmUpdateAuthor.defaultExpectation == nil {
		mmUpdateAuthor.defaultExpectation = &AuthorDTOMockUpdateAuthorExpectation{}
	}

	if mmUpdateAuthor.defaultExpectation.params != nil {
		mmUpdateAuthor.mock.t.Fatalf("AuthorDTOMock.UpdateAuthor mock is already set by Expect")
	}

	if mmUpdateAuthor.defaultExpectation.paramPtrs == nil {
		mmUpdateAuthor.defaultExpectation.paramPtrs = &AuthorDTOMockUpdateAuthorParamPtrs{}
	}
	mmUpdateAuthor.defaultExpectation.paramPtrs.author_id = &author_id

	return mmUpdateAuthor
}

// ExpectUpdateParam3 sets up expected param update for AuthorDTO.UpdateAuthor
func (mmUpdateAuthor *mAuthorDTOMockUpdateAuthor) ExpectUpdateParam3(update *models.UpdateInputAuthor) *mAuthorDTOMockUpdateAuthor {
	if mmUpdateAuthor.mock.funcUpdateAuthor != nil {
		mmUpdateAuthor.mock.t.Fatalf("AuthorDTOMock.UpdateAuthor mock is already set by Set")
	}

	if mmUpdateAuthor.defaultExpectation == nil {
		mmUpdateAuthor.defaultExpectation = &AuthorDTOMockUpdateAuthorExpectation{}
	}

	if mmUpdateAuthor.defaultExpectation.params != nil {
		mmUpdateAuthor.mock.t.Fatalf("AuthorDTOMock.UpdateAuthor mock is already set by Expect")
	}

	if mmUpdateAuthor.defaultExpectation.paramPtrs == nil {
		mmUpdateAuthor.defaultExpectation.paramPtrs = &AuthorDTOMockUpdateAuthorParamPtrs{}
	}
	mmUpdateAuthor.defaultExpectation.paramPtrs.update = &update

	return mmUpdateAuthor
}

// Inspect accepts an inspector function that has same arguments as the AuthorDTO.UpdateAuthor
func (mmUpdateAuthor *mAuthorDTOMockUpdateAuthor) Inspect(f func(ctx context.Context, author_id int, update *models.UpdateInputAuthor)) *mAuthorDTOMockUpdateAuthor {
	if mmUpdateAuthor.mock.inspectFuncUpdateAuthor != nil {
		mmUpdateAuthor.mock.t.Fatalf("Inspect function is already set for AuthorDTOMock.UpdateAuthor")
	}

	mmUpdateAuthor.mock.inspectFuncUpdateAuthor = f

	return mmUpdateAuthor
}

// Return sets up results that will be returned by AuthorDTO.UpdateAuthor
func (mmUpdateAuthor *mAuthorDTOMockUpdateAuthor) Return(s1 string, err error) *AuthorDTOMock {
	if mmUpdateAuthor.mock.funcUpdateAuthor != nil {
		mmUpdateAuthor.mock.t.Fatalf("AuthorDTOMock.UpdateAuthor mock is already set by Set")
	}

	if mmUpdateAuthor.defaultExpectation == nil {
		mmUpdateAuthor.defaultExpectation = &AuthorDTOMockUpdateAuthorExpectation{mock: mmUpdateAuthor.mock}
	}
	mmUpdateAuthor.defaultExpectation.results = &AuthorDTOMockUpdateAuthorResults{s1, err}
	return mmUpdateAuthor.mock
}

// Set uses given function f to mock the AuthorDTO.UpdateAuthor method
func (mmUpdateAuthor *mAuthorDTOMockUpdateAuthor) Set(f func(ctx context.Context, author_id int, update *models.UpdateInputAuthor) (s1 string, err error)) *AuthorDTOMock {
	if mmUpdateAuthor.defaultExpectation != nil {
		mmUpdateAuthor.mock.t.Fatalf("Default expectation is already set for the AuthorDTO.UpdateAuthor method")
	}

	if len(mmUpdateAuthor.expectations) > 0 {
		mmUpdateAuthor.mock.t.Fatalf("Some expectations are already set for the AuthorDTO.UpdateAuthor method")
	}

	mmUpdateAuthor.mock.funcUpdateAuthor = f
	return mmUpdateAuthor.mock
}

// When sets expectation for the AuthorDTO.UpdateAuthor which will trigger the result defined by the following
// Then helper
func (mmUpdateAuthor *mAuthorDTOMockUpdateAuthor) When(ctx context.Context, author_id int, update *models.UpdateInputAuthor) *AuthorDTOMockUpdateAuthorExpectation {
	if mmUpdateAuthor.mock.funcUpdateAuthor != nil {
		mmUpdateAuthor.mock.t.Fatalf("AuthorDTOMock.UpdateAuthor mock is already set by Set")
	}

	expectation := &AuthorDTOMockUpdateAuthorExpectation{
		mock:   mmUpdateAuthor.mock,
		params: &AuthorDTOMockUpdateAuthorParams{ctx, author_id, update},
	}
	mmUpdateAuthor.expectations = append(mmUpdateAuthor.expectations, expectation)
	return expectation
}

// Then sets up AuthorDTO.UpdateAuthor return parameters for the expectation previously defined by the When method
func (e *AuthorDTOMockUpdateAuthorExpectation) Then(s1 string, err error) *AuthorDTOMock {
	e.results = &AuthorDTOMockUpdateAuthorResults{s1, err}
	return e.mock
}

// Times sets number of times AuthorDTO.UpdateAuthor should be invoked
func (mmUpdateAuthor *mAuthorDTOMockUpdateAuthor) Times(n uint64) *mAuthorDTOMockUpdateAuthor {
	if n == 0 {
		mmUpdateAuthor.mock.t.Fatalf("Times of AuthorDTOMock.UpdateAuthor mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateAuthor.expectedInvocations, n)
	return mmUpdateAuthor
}

func (mmUpdateAuthor *mAuthorDTOMockUpdateAuthor) invocationsDone() bool {
	if len(mmUpdateAuthor.expectations) == 0 && mmUpdateAuthor.defaultExpectation == nil && mmUpdateAuthor.mock.funcUpdateAuthor == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateAuthor.mock.afterUpdateAuthorCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateAuthor.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateAuthor implements AuthorDTO
func (mmUpdateAuthor *AuthorDTOMock) UpdateAuthor(ctx context.Context, author_id int, update *models.UpdateInputAuthor) (s1 string, err error) {
	mm_atomic.AddUint64(&mmUpdateAuthor.beforeUpdateAuthorCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateAuthor.afterUpdateAuthorCounter, 1)

	if mmUpdateAuthor.inspectFuncUpdateAuthor != nil {
		mmUpdateAuthor.inspectFuncUpdateAuthor(ctx, author_id, update)
	}

	mm_params := AuthorDTOMockUpdateAuthorParams{ctx, author_id, update}

	// Record call args
	mmUpdateAuthor.UpdateAuthorMock.mutex.Lock()
	mmUpdateAuthor.UpdateAuthorMock.callArgs = append(mmUpdateAuthor.UpdateAuthorMock.callArgs, &mm_params)
	mmUpdateAuthor.UpdateAuthorMock.mutex.Unlock()

	for _, e := range mmUpdateAuthor.UpdateAuthorMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmUpdateAuthor.UpdateAuthorMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateAuthor.UpdateAuthorMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateAuthor.UpdateAuthorMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateAuthor.UpdateAuthorMock.defaultExpectation.paramPtrs

		mm_got := AuthorDTOMockUpdateAuthorParams{ctx, author_id, update}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateAuthor.t.Errorf("AuthorDTOMock.UpdateAuthor got unexpected parameter ctx, want: %#v, got: %#v%s\n", *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.author_id != nil && !minimock.Equal(*mm_want_ptrs.author_id, mm_got.author_id) {
				mmUpdateAuthor.t.Errorf("AuthorDTOMock.UpdateAuthor got unexpected parameter author_id, want: %#v, got: %#v%s\n", *mm_want_ptrs.author_id, mm_got.author_id, minimock.Diff(*mm_want_ptrs.author_id, mm_got.author_id))
			}

			if mm_want_ptrs.update != nil && !minimock.Equal(*mm_want_ptrs.update, mm_got.update) {
				mmUpdateAuthor.t.Errorf("AuthorDTOMock.UpdateAuthor got unexpected parameter update, want: %#v, got: %#v%s\n", *mm_want_ptrs.update, mm_got.update, minimock.Diff(*mm_want_ptrs.update, mm_got.update))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateAuthor.t.Errorf("AuthorDTOMock.UpdateAuthor got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateAuthor.UpdateAuthorMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateAuthor.t.Fatal("No results are set for the AuthorDTOMock.UpdateAuthor")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmUpdateAuthor.funcUpdateAuthor != nil {
		return mmUpdateAuthor.funcUpdateAuthor(ctx, author_id, update)
	}
	mmUpdateAuthor.t.Fatalf("Unexpected call to AuthorDTOMock.UpdateAuthor. %v %v %v", ctx, author_id, update)
	return
}

// UpdateAuthorAfterCounter returns a count of finished AuthorDTOMock.UpdateAuthor invocations
func (mmUpdateAuthor *AuthorDTOMock) UpdateAuthorAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAuthor.afterUpdateAuthorCounter)
}

// UpdateAuthorBeforeCounter returns a count of AuthorDTOMock.UpdateAuthor invocations
func (mmUpdateAuthor *AuthorDTOMock) UpdateAuthorBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateAuthor.beforeUpdateAuthorCounter)
}

// Calls returns a list of arguments used in each call to AuthorDTOMock.UpdateAuthor.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateAuthor *mAuthorDTOMockUpdateAuthor) Calls() []*AuthorDTOMockUpdateAuthorParams {
	mmUpdateAuthor.mutex.RLock()

	argCopy := make([]*AuthorDTOMockUpdateAuthorParams, len(mmUpdateAuthor.callArgs))
	copy(argCopy, mmUpdateAuthor.callArgs)

	mmUpdateAuthor.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateAuthorDone returns true if the count of the UpdateAuthor invocations corresponds
// the number of defined expectations
func (m *AuthorDTOMock) MinimockUpdateAuthorDone() bool {
	if m.UpdateAuthorMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateAuthorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateAuthorMock.invocationsDone()
}

// MinimockUpdateAuthorInspect logs each unmet expectation
func (m *AuthorDTOMock) MinimockUpdateAuthorInspect() {
	for _, e := range m.UpdateAuthorMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthorDTOMock.UpdateAuthor with params: %#v", *e.params)
		}
	}

	afterUpdateAuthorCounter := mm_atomic.LoadUint64(&m.afterUpdateAuthorCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateAuthorMock.defaultExpectation != nil && afterUpdateAuthorCounter < 1 {
		if m.UpdateAuthorMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to AuthorDTOMock.UpdateAuthor")
		} else {
			m.t.Errorf("Expected call to AuthorDTOMock.UpdateAuthor with params: %#v", *m.UpdateAuthorMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateAuthor != nil && afterUpdateAuthorCounter < 1 {
		m.t.Error("Expected call to AuthorDTOMock.UpdateAuthor")
	}

	if !m.UpdateAuthorMock.invocationsDone() && afterUpdateAuthorCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthorDTOMock.UpdateAuthor but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateAuthorMock.expectedInvocations), afterUpdateAuthorCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthorDTOMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateAuthorInspect()

			m.MinimockDeleteAuthorInspect()

			m.MinimockGetAllAuthorInspect()

			m.MinimockGetAuthorByIDInspect()

			m.MinimockUpdateAuthorInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthorDTOMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthorDTOMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateAuthorDone() &&
		m.MinimockDeleteAuthorDone() &&
		m.MinimockGetAllAuthorDone() &&
		m.MinimockGetAuthorByIDDone() &&
		m.MinimockUpdateAuthorDone()
}
